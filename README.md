# 1章
* Elasticsearch で作成したインデックスるが利用できるのは、1つ先のメジャーリリースまで
  * 5.x 系で作ったインデックスは 6.x 系でも使えるが、7.x 系では使えない

* 特徴4つ(1-2-2)
  * 分散配置による高速化と高可用性の実現
    * シャードの数を増やす => 分散配置による高速化(デフォルトは5)
    * レプリカを増やす => データロスト防止(デフォルトは1)
    * [わかりやすい資料を見つけた](https://www.slideshare.net/snuffkin/elasticsearch-as-a-distributed-system)
  * シンプルな REST API によるアクセス
  * JSONフォーマットに対応した柔軟性の高いドキュメント志向データベース
    * 事前にデータ型をスキーマとして登録しなくても、Elasticsearchは自動的にデータの型を推論してくれる(明示的に指定することも可能)
    * Elasticsearch の文脈において レコードのことをドキュメントとよぶ
    * これにより、スキーマ定義の修正対応が必要！みたいなことがなく、容易にフィールド追加もできる、らしい。
  * ログ収集・可視化などの多様な関連ソフトウェアとの連携
    * Elastic Stack と呼ばれるツール群
    * 可視化 => Kibana
    * ログ収集 => Logstash
    * サーバからのメトリクスデータ収集 => Beats
    * 監視・モニタリング、機械学習による異常検知などの有償アドオン => X-Pack

* Apatch Solr との違い(1-2-3)
  * シャード数、Elasticsearch ではインデックス作成後は変更不可！！
  * Elasticsearch ではシャードの自動リバランスをしてくれる
  * 調停方式、Elasticsearch は内臓の ZEN Discovery、Solr は Zookeeper
    * 調停方式って何？

* Elastic Stack について(1-3)
  * Elasticsearch に加えて Kibana, Logstash, Beats などの周辺ソフトウェアも含めた総称
  * Elasticsearch のバージョンは 2.4 => 5.0 とジャンプしている(2016年)が、これはその Elastic Stack でのバージョンの統一をするために行われたもの(このタイミングで Beats が加わった)

  * Kibana
    * Elasticsearch に格納されたデータを分析する際に、直接クエリを投げてもよいが、Kibana の UI を使うことでいい感じに確認することができる。
    * Tableau みたいなものか。
  * Logstash
    * input -> filter -> output
    * syslog や twitter とかからデータを取ってきて、Elasticsearch に出力する、みたいなことができる
  * Beats
    * メトリクスデータを収集・転送するための軽量データシッパー。
    * インストールされたサーバにできるだけ負荷を与えないよう、収集したデータを Elasticsearch や Logstash に転送してくれる



# 2章
## 用語と概念(2-1)
### 論理的な概念(2-1-1)
* ドキュメント
  * RDSでいうテーブルに格納される1行のレコード。JSONオブジェクト。
  * 明示的に指定しなければ一意な id は自動で採番される
* フィールド
  * key-value の組
  * Elasticsearch における転置インデックスは、フィールドごとに作成・管理されている
  * [公式のデータ型説明](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html)
  * 具体例
    * 文字列
      * text
        * 文字列からなる文章を格納
        * 格納時にアナライザによって文章を構成する各単語に分割されて、分割された単語ごとに転置インデックスが構成される
        * 部分一致用
      * keyword
        * 完全一致用の文字列格納
    * 数値
      * long、short、integer、float など
    * 日付(date)
      * フォーマットを指定して登録する
      * フォーマット例
        * "2019-09-29"
        * "2019-09-29T20:00:00"
        * "1569754800" (UNIXエポックからのミリ秒数)
    * 真偽値(boolean)
      * "true" or "false"
    * オブジェクト(object)
      * JSONオブジェクトをネストにするとき、Elasticsearch では object 型を用いるとデータ型として扱える
      * `{"book": {"title": "Elasticsearch guide", "price": "500"}}`
    * 配列(array)
      * 配列の各要素は同じデータ型をとる
      * `{"ids": [1,2,3]}`
      * `{"vms": [{"host": "web01", "flavor": "small"}, {"host": "db01", "flavor": "large"}]}`
  * マルチフィールド型という概念
    * 一つのフィールドに同時に複数のデータ型を定義できる
    * 完全一致検索と部分一致検索の両方を望むのであれば、text と keyword 両方のデータ型を定義する
    * Elasticsearch5.0からは、指定しなければ文字列はそのようにマルチフィールドとして定義されるようになっている
    * その必要がないのであれば指定すると良い
* インデックス
  * ドキュメントを格納する場所(「インデックスを作る」「インデックスに格納する」)、あるいは格納する行為自体(「インデックスする」)
    * RDSにおけるテーブルのようなものらしい
  * 格納する、と言っても、効率的な検索を行うために、転置インデックス情報をこうしたり、アナライザによって単語分割したりして、さまざまなデータ形式で保存されている
  * シャード単位に分割されて各ノードに分割して格納される
* ドキュメントタイプ
  * ドキュメントがどのようなフィールドから構成されているか？を表す概念
  * Elasticsearch6.0 からは、一つのインデックスに格納できるドキュメントタイプは一つのみとなっている。
  * Elasticsearch5系を使っている人は、ここをどうにかしないとElasticsearch7系に移すと機能しなくなる
* マッピング
  * ドキュメントタイプを具体的に定義したもの
  * API を叩いてマッピングを定義できる
  * マッピング定義がされていないと、Elasticsearch が推論して自動で定義してから格納する

### 物理的な概念(2-1-2)
* ノード
  * Elasticsearch が動作する(意味上の)サーバのこと。
  * Elasticsearch が動作する1つのJVMインスタンスをノードとみなせる
  * 物理/仮想サーバのOS上に1ノードだけ起動するのが一般的
  * 設定ファイルで指定できる一意のノード名を持っている
* クラスタ
  * 複数ノードのまとまり(ノードグループ)をクラスタと呼ぶ
  * 各ノードは設定ファイルで指定できる一意のクラスタ名を持つ。
  ＊同じクラスタ名のノードグループを見つけると、同一のクラスタを形成する。
* シャード
  * インデックスのデータを一定数に分割して異なるノードで分散保持をすることができるが、その際の分割した各部分をシャードと呼ぶ
  * シャードの実態は、具体的には Lucene インデックスファイル。
  * インデックス作成後に増やすことができない。
* レプリカ
  * ノードの可用性を高めるため、各シャードは自動的に複製される。複製されたものをレプリカと呼ぶ。
  * オリジナルのシャードをプライマリシャード、複製されたシャードをレプリカシャードと呼ぶ。
  * インデックス更新時は、まずプライマリシャードに反映され、その後レプリカシャードを複製する
  * Elasticsearch は自動でプライマリとレプリカを別のノードに割り当てる
  * 可用性だけでなく、検索性能も向上する！！！
    * 検索処理はレプリカシャードにも並列で行われるため。
    * シャード数と違ってレプリカ数はインデックス作成後も変更可能なので、レプリカ数を変えることで検索性能を上げることは可能


## システム構成(2-2)
### ノード種別(2-2-1)
* ノード種別
  * Master ノード
  * Data ノード
  * Ingest ノード
  * Coordinating ノード
* Master ノード
  * クラスタに必ず1台は Master ノードが必要
  * 役割は以下。
    * ノードのヘルスチェック
    * 以下のようなクラスタメタデータを持ち、更新情報を各ノードに伝達する
      * ノード構成情報
      * インデックスやマッピングに関する設定情報
      * シャード割当やステータスに関する情報
    * シャード割当と再配置
      * ↑の通り、Master はシャード割当に関する情報を持っているのでこれができる
  * Master が死ぬとクラスタが死ぬという状況をどう回避するか？
    * Master に昇格できる候補のノードを準備しておく。
    * そのような候補ノードを Master-eligible ノードと呼ぶ
    * デフォルト設定では、すべてのノードが Master-eligible である。( 変えるなら elasticsearch.yml のノード種別の項目を変えれば良い)
* Data ノード
  * 役割は以下。
    * 受け付けたドキュメントのインデックス格納
    * クライアント(ユーザ)からのリクエストのハンドリング
    * 個別のクエリ処理(実際の検索処理)
    * Lucene インデックスファイルのマージ等の管理
  * リクエストのハンドリング
    * ドキュメントの登録
      * 格納すべきインデックスのシャード番号を決定して、そのシャード番号を保持している Data ノードへルーティングする
    * クエリ処理リクエスト
      * クエリ内容に対応する1つ以上のシャードを持つノードへルーティングを行う(scatter phase)
      * 各ノードからのレスポンスを集約する(gather phase)
      * まとめた結果をクライアントへ返す
    * デフォルト設定では、すべてのノードが Data ノードの役割を持っている
* Ingest ノード
  * ドキュメントのインデックス格納前に、データの変換や加工をする(本来はLogstashで行うような処理)。
  * ノード上での処理フローは pipeline と呼ばれる。↑は、「pipeline で前処理をする」と表現できる
  * 前処理後は、Data ノードに送られてインデックスに格納される
  * Elasticsearch5.0 から新しく登場
  * Ingest は、直訳すると「経口摂取する」(digest は「消化する」なので、"gest" のニュアンスを感じる)
  * デフォルト設定では、すべてのノードが Ingest ノードの役割を持っている
    * Ingest ノードの役割を持っていたとしても、pipeline 定義がなければ何もしない
* Coordinating ノード
  * クライアントからのリクエストのハンドリングのみを実行する
  * (Data ノードのところに書いてあるが、)具体的には
    * インデックス登録処理時、適切なプライマリシャードを持つ Data ノードへルーティングを行う
    * クエリ処理時に scatter と gather を行った上で結果を返す
  * デフォルト設定では、すべてのノードが Coordinating ノードの役割を持っている
    * Data ノードの機能を持つノードでは Coordinating ノードの機能は off になっているということなのだろうか？
  * 敢えて Coordinating ノードのみの機能を持つノードを用意するのは、以下のようなケース
    * リクエスト処理の負荷分散をおこないたい
    * 検索結果のマージや aggregate などの負荷のかかる集計処理を Data ノードからは切り離して行いたい

### Master ノード選定とノードのクラスタ参加
* Master ノードの選定
  * Masterが死んたときのために、以下のように設定しておくべき
    * Master-eligible ノードの数を3以上の奇数にすること
    * elasticsearch.yml のパラメータ "discovery.zen.minimum_master_nodes" の数を Master-eligible ノード数の「過半数」に設定すること
  * これは「スプリットブレイン」という問題を防ぐために必要
    * 複数ノードが Master となりクラスタが2つに分断されてしまう状態
* ノードのクラスタ参加
  * 各ノードは起動時に、設定ファイルの "discovery.zen.ping.unicast.hosts" で定義されたノード群に接続を試みる。接続に成功すると、クラスタの一員として参加が認められる。
  * 一度クラスタに参加すれば、Master がヘルスチェックしてくれる。タイムアウト期間内に Master からの ping に応答できなかった場合、そのノードはクラスタから離脱したとみなされる
* ノード検知とクラスタ形成のメカニズム(discovery)
  * ↑設定ファイルの "discovery.zen." みたいな記述があるが、これはなにか？
  * discovery とは
    * Elasticsearch は、Master ノードを選定したりクラスタにノードを参加させたりするメカニズムを独自に持っているが、その仕組みを discovery と呼んでいる
  * zen とは
    * discovery のメカニズムの一つとして、デフォルトで Zen discovery というものが使われていることを示している。Zen discovery は外部ソフトウェアではなく Elasticsearch 独自のもの。
    * 例えば SolrCloud は Apache Zookeeper という外部ソフトウェアを使って調停をしている。また、kubernetes は etcd を利用している

* シャード分割とレプリカ
  * シャード数の検討観点
    * ノード数とシャード数が一致していると良いので、どれくらいのノード数にするのか？を考える
    * データサイズが十分に小さいなら、シャード数は1でいい。20〜30GBであれば1つでも十分運用可能
  * レプリカ数の検討観点
    * 検索負荷が高いとき
    * バッチ処理で大量のデータを一度にインデックスに格納する際は、レプリカの複製処理のオーバーヘッドを回避するために一時的にレプリカ数の設定を 0 にすることも検討して良い。複製が行われないため短時間で処理が完了する。



# (疑問)
* シャード数変えられないので、12に設定したした理由
* Kibana 以外の Elastic Stack どうしているのだろうか？Beats必須では？
* 構成どうなっているのだろう？
  * スプリットブレインにならないようになっている？
